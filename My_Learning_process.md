##### ﻿首次学习推荐系统相关的知识，计划将这个项目中算法相关内容翻译为中文，方便自己理解。

# 一、SAR Single Node on MovieLens

​	SAR是一种基于用户事务历史的快速可扩展自适应推荐算法。它生成可解释/说明的建议，并处理“物品冷启动”和“半用户冷启动”场景。SAR是一种基于邻域的算法，它的目的是为每个用户推荐他可能感兴趣的最热门的条目，比如说客户A看了物品1，客户B同时看了1和2，那么有可能客户A也对物品2感兴趣，则推荐给A。
	SAR推荐最“类似”于用户已有“关联”的项目。如果与一个条目交互的用户也可能与另一个条目交互，那么两个条目是“类似的”。如果用户过去曾与某项进行过交互，则该用户对该项具有“关联”。

#### SAR的优点：

​	1.精度高，便于训练和算法实现简单
	2.快速训练，只需要简单的计算来构建预测时使用的矩阵
	3.快速评分，只涉及与关联向量的相似性矩阵乘法

#### SAR的缺点：

​	1.由于它不使用项目或用户特征，相对于使用这些特征的算法，颇有劣势
	2.需要大量内存，需要创建一个 mxm 的稀疏方阵 (其中m是项数)。这对于许多矩阵分解算法来说也是一个问题
	3.SAR倾向于隐式评级方案，并不预测分数（没理解）。

#### 内容补充：

​	SAR = Similiarity Affinity Recommendation
	以下内容参考[博客](https://blog.csdn.net/csdn_47/article/details/88351075)：https://blog.csdn.net/csdn_47/article/details/88351075

##### 	SAR算法流程：

​	1.计算物品相似度矩阵$S$ 
	2.用于评估用户和物品的关系矩阵$A$ 
	3.评价分数为计算$R=A∗S$
	4.可选步骤: 包括时间衰减和移除已经看过的物品

![20190308142609352](C:\Users\windows\Desktop\20190308142609352.png)

##### 计算物品（条目）相似度$S$

​	计算相似度有多种不同的方式，不过都首先要计算物品出现的次数。假设一共有$m$种物品，则得到$m*m$大小的矩阵$C$, $c_{i,j}$代表物品$i$,$j$同时出现在一个人的事物列表中的次数，$C$满足以下条件：

- 对称： $c_{i,j}=c_{j,i}$
- 非负性：$c_{i,j}>=0$
- 单个物品出现的洗漱肯定比两两同时出现的次数大：$c_{i,i},c_{j,j}>=c_{i.j}$

可以通过三种公式计算相似度：

- `Jaccard`: $s_{ij}=\frac{c_{ij}}{(c_{ii}+c_{jj}-c_{ij})}$
- `lift`: $s_{ij}=\frac{c_{ij}}{(c_{ii} \times c_{jj})}$
- `counts`: $s_{ij}=c_{ij}$

##### 计算用品与物品之间的关联矩阵（亲和力分数）$A$

$$a_{ij}=\sum_k w_k \left(\frac{1}{2}\right)^{\frac{t_0-t_k}{T}} $$

其中$a_{i,j}$代表用户$i$对物品$j$的亲和力分数， $k$代表用户$i$对物品$j$有$k$次历史行为，$t_0$代表当前时间，$t_k$代表第$k$次行为发生的时间，时间越靠前，这次行为为亲和力分数计算的贡献越低（权重小），$w_k$ 表示不同类型事件的权重（比如点击，购买的权重不同）。$A$的大小为$n*m$, $n$个用户。

##### $S$与$A$相乘得到$n*m$的矩阵，$R_{i,j}$代表应该将物品j推荐给用户i的分数，排序之前应该将之前出现过的user/item对应位置上的值置为0, 然后进行每个用户的Top_K推荐。

# 二、